// Sprint 3

// ----------------------- 전역 -----------------------
ArrayList<Fruit> fruits = new ArrayList<Fruit>();
ArrayList<Npc> npcs = new ArrayList<Npc>();
ArrayList<FruitPiece> pieces = new ArrayList<FruitPiece>();
Knife knife;

int maxFruits = 8;
int maxNpcs = 2;

int score = 0;
int lives = 3;

final int STATE_START = 0;
final int STATE_PLAY  = 1;
final int STATE_GAMEOVER = 2;
int gameState = STATE_START;

int startMillis = 0;   // PLAY 시작 시각
float diffSpawnScale = 1.0;  // 스폰률 스케일
float diffSpeedScale = 1.0;  // 속도 스케일

// 난이도 파라미터
float baseFruitProb = 0.015;    // 기본 과일 스폰 확률/프레임
float baseNpcProb   = 0.004;    // 기본 NPC 스폰 확률/프레임
float diffUpRate    = 0.015f;   // 초당 난이도 증가율(스케일 가중)
float diffCap       = 2.2f;     // 최대 스케일

void setup() {
  size(640, 400);
  smooth();
  knife = new Knife();
}

void draw() {
  background(245);

  if (gameState == STATE_START) {
    drawStartScreen();
    return;
  }

  if (gameState == STATE_PLAY) {
    updateDifficulty();
    spawnController();

    // 업데이트 & 렌더
    for (int i = fruits.size()-1; i >= 0; i--) {
      Fruit f = fruits.get(i);
      f.update();
      f.render();
      if (f.isOut()) fruits.remove(i);
    }
    for (int i = npcs.size()-1; i >= 0; i--) {
      Npc c = npcs.get(i);
      c.update();
      c.render();
      if (c.isOut()) npcs.remove(i);
    }
    for (int i = pieces.size()-1; i >= 0; i--) {
      FruitPiece p = pieces.get(i);
      p.update();
      p.render();
      if (p.dead()) pieces.remove(i);
    }

    // 칼 표시 + 충돌
    if (mousePressed) {
      knife.update(mouseX, mouseY, pmouseX, pmouseY);
      // 과일 히트
      for (int i = fruits.size()-1; i >= 0; i--) {
        Fruit f = fruits.get(i);
        if (knife.hitCircle(f.x, f.y, f.getRadius())) {
          score += 1;
          spawnFruitPieces(f);
          fruits.remove(i);
        }
      }
      // NPC 히트
      for (int i = npcs.size()-1; i >= 0; i--) {
        Npc c = npcs.get(i);
        if (!c.dead && knife.hitCircle(c.x, c.y, npcRadius(c))) {
          c.dead = true;
          if (!c.counted) {
            lives = max(0, lives - 1);
            c.counted = true;
          }
          c.ttl = 50;
        }
      }
      knife.render();
    }

    // HUD
    drawHUD();

    // 게임오버 조건
    if (lives <= 0) {
      gameState = STATE_GAMEOVER;
    }
    return;
  }

  if (gameState == STATE_GAMEOVER) {
    // 마지막 씬 정지된 느낌 유지
    for (Fruit f : fruits) f.render();
    for (Npc c : npcs) c.render();
    for (FruitPiece p : pieces) p.render();

    drawHUD();
    drawGameOverOverlay();
  }
}

// ----------------------- 상태 전환 -----------------------
void startGame() {
  score = 0;
  lives = 3;
  fruits.clear();
  npcs.clear();
  pieces.clear();
  diffSpawnScale = 1.0;
  diffSpeedScale = 1.0;
  startMillis = millis();
  gameState = STATE_PLAY;
}

void toGameOver() {
  gameState = STATE_GAMEOVER;
}

void keyPressed() {
  if (gameState == STATE_START && (key == ' ')) {
    startGame();
  } else if (gameState == STATE_GAMEOVER && (key == ' ' || key == 'r' || key == 'R')) {
    startGame();
  }
}

// ----------------------- 난이도/스폰 -----------------------
void updateDifficulty() {
  int elapsed = (millis() - startMillis) / 1000; // 초
  float inc = 1.0 + elapsed * diffUpRate;       // 초당 조금씩 증가
  diffSpawnScale = min(diffCap, inc);
  diffSpeedScale = min(diffCap, 1.0 + elapsed * (diffUpRate * 0.7));
}

void spawnController() {
  // 과일
  if (fruits.size() < maxFruits && random(1) < baseFruitProb * diffSpawnScale) {
    fruits.add(spawnRandomFruit(diffSpeedScale));
  }
  // NPC
  if (npcs.size() < maxNpcs && random(1) < baseNpcProb * diffSpawnScale) {
    npcs.add(spawnRandomNpc(diffSpeedScale));
  }
}

// ----------------------- 전역 스폰 유틸 -----------------------
PVector randomEdgeSpawn(float margin) {
  int edge = (int)random(4);
  float x=0, y=0;
  if (edge == 0) { x = -margin; y = random(height); }
  else if (edge == 1) { x = width + margin; y = random(height); }
  else if (edge == 2) { x = random(width); y = -margin; }
  else { x = random(width); y = height + margin; }
  return new PVector(x, y);
}

Fruit spawnRandomFruit(float speedScale) {
  PVector p = randomEdgeSpawn(40);
  PVector dir = PVector.sub(new PVector(width/2, height/2), p).normalize(null);
  float spd = random(1.1, 2.0) * speedScale;  // 난이도 영향
  PVector v = dir.copy().mult(spd);
  v.x += random(-0.45, 0.45);
  v.y += random(-0.45, 0.45);

  int k = (int)random(3); // 0:사과,1:레몬,2:수박
  float size;
  if (k == 0) size = random(70, 110);
  else if (k == 1) size = random(80, 120);
  else size = random(90, 130);
  return new Fruit(p.x, p.y, v.x, v.y, size, k);
}

Npc spawnRandomNpc(float speedScale) {
  PVector p = randomEdgeSpawn(50);
  PVector dir = PVector.sub(new PVector(width/2, height/2), p).normalize(null);
  float spd = random(1.0, 1.7) * speedScale;
  PVector v = dir.copy().mult(spd);
  v.x += random(-0.35, 0.35);
  v.y += random(-0.35, 0.35);
  float size = random(90, 110);
  int kind = (int)random(3); // 0:DORA, 1:SNOOPY, 2:MUSH
  return new Npc(p.x, p.y, v.x, v.y, size, kind);
}
// ----------------------- 클래스/로직 -----------------------
class Fruit {
  float x, y, vx, vy, d;
  int kind; // 0사과 1레몬 2수박
  float margin = 40;

  Fruit(float x, float y, float vx, float vy, float d, int kind) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.d = d; this.kind = kind;
  }
  void update() { x += vx; y += vy; }
  void render() {
    if (kind == 0) drawWholeApple(x, y, d);
    else if (kind == 1) drawWholeLemon(x, y, d*1.0, d*0.75);
    else drawWholeWatermelon(x, y, d);
  }
  boolean isOut() {
    return (x < -margin || x > width + margin || y < -margin || y > height + margin);
  }
  float getRadius() {
    return d * 0.5; // 간단 근사
  }
}

class FruitPiece {
  float x, y, vx, vy, ang, vang, d;
  int kind, side; // side:-1 왼쪽, +1 오른쪽
  int ttl = 50;

  FruitPiece(float x, float y, float d, int kind, int side) {
    this.x = x; this.y = y; this.d = d; this.kind = kind; this.side = side;
    float speed = random(1.0, 1.7);
    vx = side * speed * 0.85 + random(-0.2, 0.2);
    vy = random(-0.5, 0.5);
    ang = random(-0.2, 0.2);
    vang = random(-0.05, 0.05) * side;
  }
  void update() {
    x += vx; y += vy; ang += vang;
    vy += 0.02;
    ttl--;
  }
  void render() {
    pushMatrix();
    translate(x, y);
    rotate(ang);
    drawHalfFruit(0, 0, d, kind, side);
    popMatrix();
  }
  boolean dead() { return ttl <= 0 || out(); }
  boolean out() {
    float m = 60;
    return (x < -m || x > width + m || y < -m || y > height + m);
  }
}

class Npc {
  float x, y, vx, vy, d;
  int kind;                 // 0:DORA, 1:SNOOPY, 2:MUSH
  float margin = 50;
  boolean dead = false;
  boolean counted = false;
  int ttl = 9999;

  Npc(float x, float y, float vx, float vy, float d, int kind) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.d = d; this.kind = kind;
  }
  void update() { x += vx; y += vy; if (dead) ttl--; }

  void render() {
    pushStyle(); // 수염/선 굵기 전염 방지
    if (!dead) {
      if (kind == 0) drawDoraemonAlive(x, y, d);
      else if (kind == 1) drawSnoopyAliveScaled(x, y, d);   
      else drawMushAliveScaled(x, y, d);                   
    } else {
      if (kind == 0) drawDoraemonDead(x, y, d);
      else if (kind == 1) drawSnoopyDeadScaled(x, y, d);
      else drawMushDeadScaled(x, y, d);
    }
    popStyle();
  }
  boolean isOut() {
    if (dead && ttl <= 0) return true;
    return (x < -margin || x > width + margin || y < -margin || y > height + margin);
  }
}

// 히트 반경 헬퍼
float npcRadius(Npc c) {
  if (c.kind == 1) return c.d * 0.45; // 스누피
  if (c.kind == 2) return c.d * 0.48; // 버섯
  return c.d * 0.50;                   // 도라
}

class Knife {
  float x, y, angle;
  void update(float mx, float my, float pmx, float pmy) {
    x = mx; y = my;
    float vx = mx - pmx, vy = my - pmy;
    if (abs(vx)+abs(vy) > 0.0001) angle = atan2(vy, vx);
  }
  void render() {
    pushMatrix();
    translate(x, y); rotate(angle);
    noStroke(); fill(210);
    beginShape();
    vertex(-12, -9); vertex(72, -4); vertex(114, 0); vertex(72, 4); vertex(-12, 9);
    endShape(CLOSE);
    stroke(255, 200); strokeWeight(2); line(-6, -3, 74, -1); noStroke();
    fill(60); rect(-22, -11, 5, 22, 3);
    fill(120, 80, 40); rect(-54, -8, 38, 16, 6);
    fill(90, 60, 30, 120); rect(-54, -8, 14, 16, 6);
    fill(30); ellipse(-58, 0, 11, 16);
    popMatrix();
    stroke(0, 80); strokeWeight(3); line(pmouseX, pmouseY, mouseX, mouseY); noStroke();
  }
  boolean hitCircle(float cx, float cy, float r) {
    return distPointToSegment(cx, cy, pmouseX, pmouseY, mouseX, mouseY) <= r;
  }
}

// ----------------------- 유틸 -----------------------
float distPointToSegment(float px, float py, float x1, float y1, float x2, float y2) {
  float vx = x2 - x1, vy = y2 - y1;
  float wx = px - x1, wy = py - y1;
  float c1 = vx*wx + vy*wy;
  if (c1 <= 0) return dist(px, py, x1, y1);
  float c2 = vx*vx + vy*vy;
  if (c2 <= c1) return dist(px, py, x2, y2);
  float t = c1 / c2;
  float projx = x1 + t * vx, projy = y1 + t * vy;
  return dist(px, py, projx, projy);
}

void spawnFruitPieces(Fruit f) {
  float offset = 6;
  pieces.add(new FruitPiece(f.x - offset, f.y, f.d, f.kind, -1));
  pieces.add(new FruitPiece(f.x + offset, f.y, f.d, f.kind, +1));
}

// ----------------------- 렌더(과일 통/반쪽) -----------------------
void drawWholeApple(float x, float y, float d) {
  fill(220, 30, 40); ellipse(x, y, d, d);
  fill(220, 30, 40); ellipse(x, y-5, d*0.95, d*0.92);
  fill(110, 70, 30); rect(x-5, y - d/2 - 12, 10, 22, 3);
  pushMatrix(); translate(x + 28, y - d/2 + 8); rotate(-PI/6);
  fill(60, 170, 80); ellipse(0, 0, 34, 18); popMatrix();
  fill(255, 255, 255, 90); ellipse(x - d*0.22, y - d*0.22, d*0.28, d*0.28);
}

void drawWholeLemon(float x, float y, float w, float h) {
  fill(255, 220, 50); ellipse(x, y, w, h);
  fill(255, 220, 50);
  triangle(x - w/2, y, x - w/2 - 15, y, x - w/2, y - 5);
  triangle(x + w/2, y, x + w/2 + 15, y, x + w/2, y + 5);
  fill(255, 255, 255, 80); ellipse(x - w*0.25, y - h*0.25, w*0.25, h*0.25);
}

void drawWholeWatermelon(float x, float y, float d) {
  fill(0, 150, 0); ellipse(x, y, d, d);
  stroke(0, 100, 0); strokeWeight(6);
  for (int i = -2; i <= 2; i++) {
    float a = radians(i * 20);
    float x1 = x + cos(a) * d/2, y1 = y + sin(a) * d/2;
    line(x, y, x1, y1);
  }
  noStroke();
  fill(255, 255, 255, 60); ellipse(x - d*0.2, y - d*0.2, d*0.3, d*0.3);
}

void drawHalfFruit(float cx, float cy, float d, int kind, int side) {
  if (kind == 0) {
    fill(220, 30, 40);
    arc(cx + side*35, cy, d, d, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    fill(255, 245, 220);
    arc(cx + side*40, cy, d-24, d-24, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
  } else if (kind == 1) {
    float w = d*1.0, h = d*0.75;
    fill(255, 220, 50);
    arc(cx + side*30, cy, w, h, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    fill(255, 245, 120);
    arc(cx + side*35, cy, w-25, h-25, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
  } else {
    fill(0, 150, 0);
    arc(cx + side*35, cy, d, d, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    fill(255, 60, 80);
    arc(cx + side*40, cy, d-20, d-20, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    fill(0);
    if (side<0) { ellipse(cx - 10, cy - 10, 5, 8); ellipse(cx - 8, cy + 8, 5, 8); }
    else { ellipse(cx + 10, cy - 10, 5, 8); ellipse(cx + 8, cy + 8, 5, 8); }
  }
}

// ----------------------- 도라에몽 -----------------------
void drawDoraemonAlive(float x, float y, float d) {
  stroke(0);
  fill(0,150,255); circle(x,y,d);
  fill(255); ellipse(x, y+10, d-15, 80);

  fill(255); ellipse(x-10, y-25, d-80, 30);
  fill(0);   ellipse(x-6,  y-23, d-90, 20);
  fill(255); ellipse(x-5,  y-22, d-97, 8);

  fill(255); ellipse(x+10, y-25, d-80, 30);
  fill(0);   ellipse(x+6,  y-23, d-90, 20);
  fill(255); ellipse(x+5,  y-22, d-97, 8);

  fill(255,0,0); circle(x, y-10, d-90);
  fill(255); arc(x, y+7, d-30, d-30, 0, PI);

  stroke(0); strokeWeight(max(2, d*0.02));
  line(x, y-5, x, y+40);
  line(x-20, y-10, x-45, y-20);
  line(x-20, y,    x-50, y);
  line(x-20, y+10, x-45, y+20);
  line(x+20, y-10, x+45, y-20);
  line(x+20, y,    x+50, y);
  line(x+20, y+10, x+45, y+20);
  noStroke();
}

void drawDoraemonDead(float x, float y, float d) {
  stroke(0);
  fill(0,150,255); circle(x,y,d);
  fill(255); ellipse(x, y+10, d-15, 80);
  fill(255,0,0); circle(x, y-10, d-90);
  fill(255); arc(x, y+7, d-30, d-30, 0, PI);

  stroke(0); strokeWeight(max(3, d*0.025));
  float lx = x - 10, ly = y - 25;
  line(lx-12, ly-10, lx+12, ly+10);
  line(lx-12, ly+10, lx+12, ly-10);
  float rx = x + 10, ry = y - 25;
  line(rx-12, ry-10, rx+12, ry+10);
  line(rx-12, ry+10, rx+12, ry-10);

  stroke(0, 140); strokeWeight(max(2, d*0.02));
  line(x, y-5, x, y+40);
  line(x-20, y-10, x-45, y-20);
  line(x-20, y,    x-50, y);
  line(x-20, y+10, x-45, y+20);
  line(x+20, y-10, x+45, y-20);
  line(x+20, y,    x+50, y);
  line(x+20, y+10, x+45, y+20);
  noStroke();
}
// Snoopy (Alive) 
void drawSnoopyAliveScaled(float x, float y, float D) {
  float d = D / 18.0;
  fill(255);
  arc(x ,y+4*d,20*d,14*d,PI,3*PI/2);
  arc(x,y-5.6*d,8*d,5.2*d,0,PI/2);
  fill(255);
  arc(x+8*d,y-5.6*d,8*d,4.8*d,PI,3*PI/2);
  arc(x+8*d,y,13.6*d,16*d,3*PI/2,2*PI);
  arc(x+12*d,y,5.6*d,20*d,0,13*PI/12);
  arc(x+2*d,y+4*d,24*d,10*d,PI/4,PI);
  arc(x-9.6*d,y+4*d,4*d,2.4*d,PI,3*PI/2);
  arc(x-11.2*d,y+4*d,0.8*d,3.2*d,PI/2,PI);
  arc(x-11.2*d,y+4.6*d,3.2*d,2*d,0,PI/2);
  noStroke();
  fill(255);
  ellipse(x+3.6*d,y-0.4*d,1.2*d,2.8*d);  // 눈
  fill(0);
  ellipse(x-10.4*d,y+4.6*d,1.6*d,1.2*d); // 코
  ellipse(x+12*d,y+2.8*d,3.2*d,11.2*d);  // 귀
}

// Snoopy (Dead, X눈) 
void drawSnoopyDeadScaled(float x, float y, float D) {
  float d = D / 18.0;
  fill(255);
  arc(x ,y+4*d,20*d,14*d,PI,3*PI/2);
  arc(x,y-5.6*d,8*d,5.2*d,0,PI/2);
  fill(255);
  arc(x+8*d,y-5.6*d,8*d,4.8*d,PI,3*PI/2);
  arc(x+8*d,y,13.6*d,16*d,3*PI/2,2*PI);
  arc(x+12*d,y,5.6*d,20*d,0,13*PI/12);
  arc(x+2*d,y+4*d,24*d,10*d,PI/4,PI);
  arc(x-9.6*d,y+4*d,4*d,2.4*d,PI,3*PI/2);
  arc(x-11.2*d,y+4*d,0.8*d,3.2*d,PI/2,PI);
  arc(x-11.2*d,y+4.6*d,3.2*d,2*d,0,PI/2);
  // X 눈
  stroke(0);
  float ex = x+3.6*d, ey = y-0.4*d, s = 1.2*d;
  line(ex - s, ey - s, ex + s, ey + s);
  line(ex - s, ey + s, ex + s, ey - s);
  noStroke();
  fill(0);
  ellipse(x-10.4*d,y+4.6*d,1.6*d,1.2*d);
  ellipse(x+12*d,y+2.8*d,3.2*d,11.2*d);
}

// Mushroom (Alive)
void drawMushAliveScaled(float x, float y, float D) {
  float d = D / 12.0;
  fill(255); stroke(0);
  circle(x, y, 7.5 * d);
  circle(x + 1.5 * d, y - 0.25 * d, 2 * d);
  fill(0); stroke(0);
  circle(x + d, y - 0.2 * d, d);
  fill(255); stroke(0);
  circle(x - 1.5 * d, y - 0.25 * d, 2 * d);
  fill(0); stroke(0);
  circle(x - d, y - 0.2 * d, d);
  fill(255, 0, 0); stroke(0);
  circle(x, y + 1.875 * d, 1.5 * d);
  fill(255, 166, 0); noStroke();
  arc(x, y - 2 * d, 10 * d, 3.75 * d, PI, 2 * PI);
}

// Mushroom (Dead, X눈)
void drawMushDeadScaled(float x, float y, float D) {
  float d = D / 12.0;
  fill(255); stroke(0);
  circle(x, y, 7.5 * d);
  // X눈
  stroke(0);
  float rx = x + 1.5 * d, ry = y - 0.25 * d, rs = d;
  line(rx - rs, ry - rs, rx + rs, ry + rs);
  line(rx - rs, ry + rs, rx + rs, ry - rs);
  float lx = x - 1.5 * d, ly = y - 0.25 * d, ls = d;
  line(lx - ls, ly - ls, lx + ls, ly + ls);
  line(lx - ls, ly + ls, lx + ls, ly - ls);
  // 입/모자
  fill(255, 0, 0); stroke(0);
  circle(x, y + 1.875 * d, 1.5 * d);
  fill(255, 166, 0); noStroke();
  arc(x, y - 2 * d, 10 * d, 3.75 * d, PI, 2 * PI);
}


// ----------------------- HUD / 화면 -----------------------
void drawHUD() {
  // 상단 바
  noStroke();
  fill(0, 0, 0, 70);
  rect(0, 0, width, 42);

  // 점수
  fill(255);
  textAlign(LEFT, CENTER);
  textSize(16);
  text("SCORE : " + score, 12, 21);

  // 시간
  int elapsed = (millis() - startMillis) / 1000;
  String t = nf(elapsed/60, 2) + ":" + nf(elapsed%60, 2);
  textAlign(CENTER, CENTER);
  text("TIME : " + t, width/2, 21);

  // 목숨(하트)
  textAlign(LEFT, CENTER);
  float heartX = width - 20;
  for (int i = 0; i < 3; i++) {
    boolean filled = (i < lives);
    drawHeart(heartX - i*22, 21, 14, filled);
  }
}

void drawHeart(float cx, float cy, float s, boolean filled) {
  pushMatrix();
  translate(cx, cy);
  if (filled) fill(255, 70, 90);
  else { noFill(); stroke(255, 120, 130); strokeWeight(2); }
  float r = s * 0.32;
  if (filled) {
    noStroke();
    ellipse(-r, -r, s*0.6, s*0.6);
    ellipse(+r, -r, s*0.6, s*0.6);
    triangle(-s*0.45, -r*0.2, s*0.45, -r*0.2, 0, s*0.55);
  } else {
    beginShape();
    vertex(0, s*0.55);
    bezierVertex(s*0.6, -s*0.2, s*0.35, -s*0.75, 0, -s*0.35);
    bezierVertex(-s*0.35, -s*0.75, -s*0.6, -s*0.2, 0, s*0.55);
    endShape();
  }
  popMatrix();
}

void drawStartScreen() {
  fill(0, 120);
  textAlign(CENTER, CENTER);
  textSize(28);
  text("FRUIT CUTTER", width/2, height/2 - 40);

  textSize(14);
  text("Fruit +1, Character -1", width/2, height/2 - 8);
  text("Start with Space", width/2, height/2 + 34);
}

void drawGameOverOverlay() {
  noStroke();
  fill(0, 0, 0, 160);
  rect(0, 0, width, height);

  fill(255);
  textAlign(CENTER, CENTER);
  textSize(34);
  text("GAME OVER", width/2, height/2 - 36);

  textSize(18);
  text("Score : " + score, width/2, height/2 + 2);

  int elapsed = (millis() - startMillis) / 1000;
  String t = nf(elapsed/60, 2) + ":" + nf(elapsed%60, 2);
  text("Time  : " + t, width/2, height/2 + 26);

  textSize(14);
  text("Restart with SPACE / R ", width/2, height/2 + 54);
}
