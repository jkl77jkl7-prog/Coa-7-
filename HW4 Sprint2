// ======================= Sprint 2 (로직 확장) =======================
// - 칼 세그먼트 충돌
// - 과일 히트: 점수+1, 잘린 조각 2개 스폰 후 서서히 사라짐
// - 캐릭터 히트: X눈, 목숨-1, 잠깐 표시 후 삭제
// - 화면 밖 삭제

ArrayList<Fruit> fruits = new ArrayList<Fruit>();
ArrayList<Npc> npcs = new ArrayList<Npc>();
ArrayList<FruitPiece> pieces = new ArrayList<FruitPiece>();
Knife knife;

int maxFruits = 8;
int maxNpcs = 2;

int score = 0;
int lives = 3;

void setup() {
  size(640, 400);
  smooth();
  knife = new Knife();
}

void draw() {
  // 프레임 기본 스타일(전염 최소화)
  noStroke();
  fill(255);

  background(245);

  spawnController();

  // 과일 업데이트/렌더
  for (int i = fruits.size()-1; i >= 0; i--) {
    Fruit f = fruits.get(i);
    f.update();
    f.render();
    if (f.isOut()) fruits.remove(i);
  }

  // 캐릭터 업데이트/렌더
  for (int i = npcs.size()-1; i >= 0; i--) {
    Npc c = npcs.get(i);
    c.update();
    c.render();
    if (c.isOut()) npcs.remove(i);
  }

  // 잘린 조각들 업데이트/렌더
  for (int i = pieces.size()-1; i >= 0; i--) {
    FruitPiece p = pieces.get(i);
    p.update();
    p.render();
    if (p.dead()) pieces.remove(i);
  }

  // 칼 표시 및 충돌 체크
  if (mousePressed) {
    knife.update(mouseX, mouseY, pmouseX, pmouseY);
    // 충돌 판정: 과일
    for (int i = fruits.size()-1; i >= 0; i--) {
      Fruit f = fruits.get(i);
      float r = f.getRadius();
      if (knife.hitCircle(f.x, f.y, r)) {
        // 잘림: 점수+, 과일 제거, 조각 2개 스폰
        score += 1;
        spawnFruitPieces(f);
        fruits.remove(i);
      }
    }
    // 충돌 판정: 캐릭터
    for (int i = npcs.size()-1; i >= 0; i--) {
      Npc c = npcs.get(i);
      if (!c.dead && knife.hitCircle(c.x, c.y, c.d*0.5)) {
        c.dead = true;           // X눈 전환
        if (!c.counted) {        // 중복 차감 방지
          lives = max(0, lives - 1);
          c.counted = true;
        }
        c.ttl = 45;              // 잠깐 보였다가 사라짐
      }
    }
    knife.render();
  }

  // 임시 HUD
  fill(0, 160);
  textAlign(LEFT, TOP);
  text("Score: " + score + "   Lives: " + lives + "   Fruits: " + fruits.size() + "   NPCs: " + npcs.size(), 10, 10);
  text("Sprint 2: 클릭해서 칼을 그리면 자름(과일 +1 / 캐릭터 -1 life)", 10, 28);
}

// ======================= 스폰 컨트롤러 =======================
void spawnController() {
  if (fruits.size() < maxFruits && random(1) < 0.02) {
    fruits.add(spawnRandomFruit());
  }
  if (npcs.size() < maxNpcs && random(1) < 0.006) {
    npcs.add(spawnRandomNpcDora());
  }
}

// ======================= 전역 스폰 유틸 =======================
PVector randomEdgeSpawn(float margin) {
  int edge = (int)random(4);
  float x=0, y=0;
  if (edge == 0) { x = -margin; y = random(height); }
  else if (edge == 1) { x = width + margin; y = random(height); }
  else if (edge == 2) { x = random(width); y = -margin; }
  else { x = random(width); y = height + margin; }
  return new PVector(x, y);
}

Fruit spawnRandomFruit() {
  PVector p = randomEdgeSpawn(40);
  PVector toCenter = PVector.sub(new PVector(width/2, height/2), p).normalize(null);
  float spd = random(1.2, 2.2);
  PVector v = toCenter.copy().mult(spd);
  v.x += random(-0.5, 0.5);
  v.y += random(-0.5, 0.5);

  int k = (int)random(3); // 0:사과,1:레몬,2:수박
  float size;
  if (k == 0) size = random(70, 110);
  else if (k == 1) size = random(80, 120);
  else size = random(90, 130);
  return new Fruit(p.x, p.y, v.x, v.y, size, k);
}

Npc spawnRandomNpcDora() {
  PVector p = randomEdgeSpawn(50);
  PVector toCenter = PVector.sub(new PVector(width/2, height/2), p).normalize(null);
  float spd = random(1.2, 2.0);
  PVector v = toCenter.copy().mult(spd);
  v.x += random(-0.4, 0.4);
  v.y += random(-0.4, 0.4);
  float size = random(90, 110);
  return new Npc(p.x, p.y, v.x, v.y, size);
}

// ======================= Fruit =======================
class Fruit {
  float x, y;
  float vx, vy;
  float d;      // 크기 기준
  int kind;     // 0:사과, 1:레몬, 2:수박
  float margin = 40;

  Fruit(float x, float y, float vx, float vy, float d, int kind) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.d = d; this.kind = kind;
  }

  void update() {
    x += vx;
    y += vy;
  }

  void render() {
    if (kind == 0) drawWholeApple(x, y, d);
    else if (kind == 1) drawWholeLemon(x, y, d*1.0, d*0.75);
    else drawWholeWatermelon(x, y, d);
  }

  boolean isOut() {
    return (x < -margin || x > width + margin || y < -margin || y > height + margin);
  }

  float getRadius() {
    if (kind == 1) return (d*0.5); // 레몬: 대충 반지름 근사
    return d*0.5;
  }
}

// ======================= FruitPiece (잘린 조각) =======================
class FruitPiece {
  float x, y;
  float vx, vy;
  float ang, vang;
  float d;
  int kind;    // 0사과,1레몬,2수박
  int side;    // -1:왼쪽, +1:오른쪽
  int ttl = 45;

  FruitPiece(float x, float y, float d, int kind, int side) {
    this.x = x; this.y = y; this.d = d; this.kind = kind; this.side = side;
    float speed = random(1.2, 2.0);
    vx = side * speed * 0.8 + random(-0.2, 0.2);
    vy = random(-0.6, 0.6);
    ang = random(-0.2, 0.2);
    vang = random(-0.05, 0.05) * side;
  }

  void update() {
    x += vx;
    y += vy;
    ang += vang;
    vy += 0.02;      // 약한 중력
    ttl--;
  }

  void render() {
    pushMatrix();
    translate(x, y);
    rotate(ang);
    drawHalfFruit(0, 0, d, kind, side);
    popMatrix();
  }

  boolean dead() { return ttl <= 0 || out(); }

  boolean out() {
    float m = 60;
    return (x < -m || x > width + m || y < -m || y > height + m);
  }
}

void spawnFruitPieces(Fruit f) {
  float offset = 6;
  pieces.add(new FruitPiece(f.x - offset, f.y, f.d, f.kind, -1));
  pieces.add(new FruitPiece(f.x + offset, f.y, f.d, f.kind, +1));
}

// 과일 반쪽 그리기
void drawHalfFruit(float cx, float cy, float d, int kind, int side) {
  // side: -1 왼쪽, +1 오른쪽
  if (kind == 0) {
    // 사과
    // 껍질
    fill(220, 30, 40);
    arc(cx + side*35, cy, d, d, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    // 속살
    fill(255, 245, 220);
    arc(cx + side*40, cy, d-24, d-24, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
  } else if (kind == 1) {
    // 레몬(타원)
    float w = d*1.0, h = d*0.75;
    fill(255, 220, 50);
    arc(cx + side*30, cy, w, h, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    fill(255, 245, 120);
    arc(cx + side*35, cy, w-25, h-25, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
  } else {
    // 수박
    fill(0, 150, 0);
    arc(cx + side*35, cy, d, d, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    fill(255, 60, 80);
    arc(cx + side*40, cy, d-20, d-20, (side<0?HALF_PI: -HALF_PI), (side<0?PI+HALF_PI: HALF_PI), PIE);
    // 씨앗
    fill(0);
    if (side<0) {
      ellipse(cx - 10, cy - 10, 5, 8);
      ellipse(cx - 8, cy + 8, 5, 8);
    } else {
      ellipse(cx + 10, cy - 10, 5, 8);
      ellipse(cx + 8, cy + 8, 5, 8);
    }
  }
}

// ======================= NPC (도라에몽) =======================
class Npc {
  float x, y;
  float vx, vy;
  float d;
  float margin = 50;
  boolean dead = false;
  boolean counted = false; // 목숨 차감 1회만
  int ttl = 9999;

  Npc(float x, float y, float vx, float vy, float d) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.d = d;
  }

  void update() {
    x += vx;
    y += vy;
    if (dead) ttl--;
  }

  void render() {
    if (!dead) drawDoraemonAlive(x, y, d);
    else drawDoraemonDead(x, y, d); // X 눈
  }

  boolean isOut() {
    if (dead && ttl <= 0) return true;
    return (x < -margin || x > width + margin || y < -margin || y > height + margin);
  }
}

// ======================= Knife =======================
class Knife {
  float x, y;
  float angle;

  void update(float mx, float my, float pmx, float pmy) {
    x = mx; y = my;
    float vx = mx - pmx;
    float vy = my - pmy;
    if (abs(vx)+abs(vy) > 0.0001) angle = atan2(vy, vx);
    // 궤적은 pmouse → mouse를 세그먼트로 사용
  }

  void render() {
    pushMatrix();
    translate(x, y);
    rotate(angle);

    // 칼날
    noStroke();
    fill(210);
    beginShape();
    vertex(-12, -9);
    vertex(72, -4);
    vertex(114, 0);
    vertex(72, 4);
    vertex(-12, 9);
    endShape(CLOSE);

    // 하이라이트
    stroke(255, 200);
    strokeWeight(2);
    line(-6, -3, 74, -1);
    noStroke();

    // 가드
    fill(60);
    rect(-22, -11, 5, 22, 3);

    // 손잡이
    fill(120, 80, 40);
    rect(-54, -8, 38, 16, 6);
    fill(90, 60, 30, 120);
    rect(-54, -8, 14, 16, 6);
    fill(30);
    ellipse(-58, 0, 11, 16);

    popMatrix();

    // 시각적 궤적(선)
    stroke(0, 80);
    strokeWeight(3);
    line(pmouseX, pmouseY, mouseX, mouseY);
    noStroke();
  }

  // 세그먼트-원 충돌
  boolean hitCircle(float cx, float cy, float r) {
    return distPointToSegment(cx, cy, pmouseX, pmouseY, mouseX, mouseY) <= r;
  }
}

// 점-세그먼트 최소거리
float distPointToSegment(float px, float py, float x1, float y1, float x2, float y2) {
  float vx = x2 - x1, vy = y2 - y1;
  float wx = px - x1, wy = py - y1;
  float c1 = vx*wx + vy*wy;
  if (c1 <= 0) return dist(px, py, x1, y1);
  float c2 = vx*vx + vy*vy;
  if (c2 <= c1) return dist(px, py, x2, y2);
  float t = c1 / c2;
  float projx = x1 + t * vx;
  float projy = y1 + t * vy;
  return dist(px, py, projx, projy);
}

// ======================= 렌더 함수: 과일 3종(통) =======================
void drawWholeApple(float x, float y, float d) {
  fill(220, 30, 40);
  ellipse(x, y, d, d);
  fill(220, 30, 40);
  ellipse(x, y-5, d*0.95, d*0.92);
  fill(110, 70, 30);
  rect(x-5, y - d/2 - 12, 10, 22, 3);
  pushMatrix();
  translate(x + 28, y - d/2 + 8);
  rotate(-PI/6);
  fill(60, 170, 80);
  ellipse(0, 0, 34, 18);
  popMatrix();
  fill(255, 255, 255, 90);
  ellipse(x - d*0.22, y - d*0.22, d*0.28, d*0.28);
}

void drawWholeLemon(float x, float y, float w, float h) {
  fill(255, 220, 50);
  ellipse(x, y, w, h);
  fill(255, 220, 50);
  triangle(x - w/2, y, x - w/2 - 15, y, x - w/2, y - 5);
  triangle(x + w/2, y, x + w/2 + 15, y, x + w/2, y + 5);
  fill(255, 255, 255, 80);
  ellipse(x - w*0.25, y - h*0.25, w*0.25, h*0.25);
}

void drawWholeWatermelon(float x, float y, float d) {
  fill(0, 150, 0);
  ellipse(x, y, d, d);
  stroke(0, 100, 0);
  strokeWeight(6);
  for (int i = -2; i <= 2; i++) {
    float angle = radians(i * 20);
    float x1 = x + cos(angle) * d/2;
    float y1 = y + sin(angle) * d/2;
    line(x, y, x1, y1);
  }
  noStroke();
  fill(255, 255, 255, 60);
  ellipse(x - d*0.2, y - d*0.2, d*0.3, d*0.3);
}

// ======================= 도라에몽 (Alive / Dead) =======================
void drawDoraemonAlive(float x, float y, float d) {
  stroke(0);
  fill(0,150,255);
  circle(x,y,d);

  fill(255);
  ellipse(x, y+10, d-15, 80);

  fill(255);
  ellipse(x-10, y-25, d-80, 30);
  fill(0);
  ellipse(x-6, y-23, d-90, 20);
  fill(255);
  ellipse(x-5, y-22, d-97, 8);

  fill(255);
  ellipse(x+10, y-25, d-80, 30);
  fill(0);
  ellipse(x+6, y-23, d-90, 20);
  fill(255);
  ellipse(x+5, y-22, d-97, 8);

  fill(255,0,0);
  circle(x, y-10, d-90);

  fill(255);
  arc(x, y+7, d-30, d-30, 0, PI);

  // 수염과 코밑 라인
  stroke(0);
  strokeWeight(max(2, d*0.02));
  line(x, y-5, x, y+40);

  line(x-20, y-10, x-45, y-20);
  line(x-20, y,    x-50, y);
  line(x-20, y+10, x-45, y+20);

  line(x+20, y-10, x+45, y-20);
  line(x+20, y,    x+50, y);
  line(x+20, y+10, x+45, y+20);

  noStroke();
}

void drawDoraemonDead(float x, float y, float d) {
  // 기본 얼굴/코/입은 동일
  stroke(0);
  fill(0,150,255);
  circle(x,y,d);

  fill(255);
  ellipse(x, y+10, d-15, 80);

  fill(255,0,0);
  circle(x, y-10, d-90);

  fill(255);
  arc(x, y+7, d-30, d-30, 0, PI);

  // X눈
  stroke(0);
  strokeWeight(max(3, d*0.025));
  // 왼쪽 X
  float lx = x - 10, ly = y - 25;
  line(lx-12, ly-10, lx+12, ly+10);
  line(lx-12, ly+10, lx+12, ly-10);
  // 오른쪽 X
  float rx = x + 10, ry = y - 25;
  line(rx-12, ry-10, rx+12, ry+10);
  line(rx-12, ry+10, rx+12, ry-10);

  // 수염
  stroke(0, 140);
  strokeWeight(max(2, d*0.02));
  line(x, y-5, x, y+40);
  line(x-20, y-10, x-45, y-20);
  line(x-20, y,    x-50, y);
  line(x-20, y+10, x-45, y+20);
  line(x+20, y-10, x+45, y-20);
  line(x+20, y,    x+50, y);
  line(x+20, y+10, x+45, y+20);

  noStroke();
}
